---
title: 운영체제
---
## 파일시스템
### 페이지캐시
- 파일을 SSD에서 읽을 때 파일을 메모리캐시에 넣어놓고 읽는 것

### i-node
- 파일은 i-node 넘버를 가지고 있으며 i-node는 15개의 포인터로 이뤄진 블럭
- i-node 블럭은 파일에 대한 메타데이터, 파일의 실제 데이터 블럭의 위치 등으로 이뤄짐
- 하드링크: 하드링크는 i-node를 가리키며 여러개의 하드링크가 동일한 i-node를 가리킬 수 있음
  - 하드링크가 삭제되어도 원본파일은 지장받지 않음
- 소프트링크: 

### 버퍼캐시

## 가상메모리, 페이지, Thrashing
### 가상메모리
- 프로세스가 실행될 때 중요한 것들만 메모리에 올려놓고 프로세스의 내용 중 다른 중요하지 않은 것들은 디스크에 올려 물리메모리와 디스크의 메모리를 합쳐 가상메모리로 사용하는 방식
  - SWAP 영역: 디스크의 메모리 영역
  - 페이지(Page): 가상 메모리를 사용하는 최소 크기 단위.
  - 프레임(Frame): 물리 메모리를 사용하는 최소 크기 단위.
- Demand Paging: 프로그램을 실행 시 프로세스를 구성하는 모든 페이지를 물리적 메모리에 올리지 않고 당장 필요한 페이지만 메모리에 올리기 때문이며 이런 방식을 요구 페이징(Demand paging)
- 페이지폴트: CPU가 프로그램을 실행하면서 필요한 페이지가 물리적 메모리에 없는 경우도 생기게 되는데 이것을 페이지 폴트(Page Fault)
- Page Replacement 알고리즘: 물리적 메모리에 비어있는 프레임이 존재하지 않는 경우
  - FIFO(First In First Out): 가장 먼저 물리 메모리에 적재된 페이지를 선택하는 방식.
  - LRU(Least Recent Used): 가장 오랫동안 사용되지 않았던 page를 선택하는 방식.
  - LRU Approximation: LRU와 같지만, 페이지에 Second-Chance를 준다.
  - 클럭 알고리즘

- 문제: 메모리 부족하면 디스크의 SWAP 영역으로 안쓰는 메모리 쫓아냄 -> 메모리에 구멍, SWAP 하는데 걸리는 시간 문제
- 해결
  - 메모리를 조그만 크기로 나누기: Frame
  - 프로그램을 Frame과 동일한 크기로 나누기: Page
  - 페이지 사용으로 메모리 순서 엉망 -> 페이지 테이블 사용해 논리, 물리 메모리 주소 변환
  - TLB에 메모리 주소가 있으면 바로 가져옴, 없으면 Page Table에서 가져옴

### Linux의 메모리 관리
- SWAP 영역 접근하기 위해 OS 권한 필요 -> MMU CPU 정지 -> OS가 SWAP 공간에서 메모리 가져온 후 TLB에 주소 등록
  - SWAP 영역에서 데이터 가져오는데 시간이 많이 걸림 -> 다른 프로세스가 CPU 사용할 수도 있음 -> 페이지 폴트 성능이 CPU 성능이 됨

### Thrashing
- 메모리가 페이지로 꽉 차있을 경우 명령을 조금만 수행해도 페이지 폴트가 발생 -> 다른 프로세스 CPU 할당 -> 페이지 폴트 -> 반복 -> 모든 프로세스가 페이지 폴트 -> CPU는 할일이 없으므로 OS는 더 많은 프로세스 메모리에 할당 -> Thrashing 발생
- 해소방법
  - Working Set Algorithm
    - 특정 시간동안 참조되는 페이지의 개수를 파악해 그 숫자만큼 프레임이 확보되면 그 때 페이지를 메모리에 로드
    - Page Replacement 시에도 그 숫자만큼 페이지를 SWAP 영역으로 쫓아냄
    - Page Fault Frequency: Page Fault 상한과 하한을 둬 상한을 넘으면 지급 프레임 개수 늘리고 하한을 넘으면 지급 프레임 개수 줄임


## Web Socket
- Polling
  - 클라이언트가 서버로 계속 요청
- Long Polling
  - 클라이언트가 서버로 요청하고 대기
- Streaming
  - 클라이언트가 요청 후 서버가 이벤트 있으면 계속 보내는 방식

# 프로세스
실행중인 프로그램 인스턴스

# 스레드
프로세스 내의 실행 흐름

# 데드락
* 프로세스가 서로의 자원(IO, CPU, memory 등)을 선점하려 기다리는 상태

## 데드락 조건
### Mutual exclusion 상호 배제
* 매 순간 하나의 프로세스만이 자원을 사용
### No preemption 비선점
* 프로레스는 자원을 스스로 내어놓을 뿐 강제로 빼앗기지 않음
### Hold and wait 보유대기
* 자원을 가진 프로세스가 다른 자원을 기다릴 때 보유 자원을 놓지 않고 계속 가지고 있음.
### Circular wait 순환대기
* 자원을 기다리는 프로세스간에 사이클이 형성되어야 함

# 스케줄링 기법
* FCFS
* SJF
* 선점, 비선점
* Round Robin
* Multi Level Queue

# 세마포어 VS 뮤텍스
* 뮤텍스: 상호 배제를 보장, 하나의 스레드만 접근 가능.
* 세마포어: 카운터변수를 통해 여러 스레드가 접근 가능, 카운터 값 만큼 동시 접근 허용.
* 임계구역: 공유 자원에 접속하는 코드


# 시스템콜

# 페이징
# 세그멘테이션

# 멀티프로세싱 VS 멀티태스킹 vs 멀티스레딩
## 멀티프로세싱
* 여러개의 CPU코어가 병렬로 작업을 수행
## 멀티태스킹
* 하나의 CPU에서 여러 프로세스가 번갈아가며 짧은 시간 작업 수행
## 멀티스레딩
* 하나의 프로세스 내에 여러 스레드

# 멀티 프로세스
* 부모 프로세스가 여러 자식 프로세스를 가지고 있는 것

# 데몬 vs 서비스
* 데몬: 리눅스용 백그라운드 프로세스
* 서비스: 윈도우용 백그라운드 프로세스

# 코드 데이터 스택 힙
## 코드
* 프로그램 인스트럭션 저장

## 데이터
* 전역변수, 정적변수

## 스택
* 정적 메모리 할당에 사용, 컴파일 타임에 크기가 결정
* 함수 호출, 지역 변수가 저장

## 힙
* 동적 메모리 할당에 사용, 런타임 크기 결정
* new, 객체 인스턴스 저장

# 오버플로우
* 힙이 스택을 침범하는 경우를 힙 오버 플로우라 하고, 스택이 힙을 침범하는 경우를 스택 오버 플로우
* 힙은 메모리 위쪽 주소부터 할당되고, 스택은 메모리 아래쪽 주소부터 할당되기 때문에 각 영역이 상대 공간을 침범하는 일이 발생할 수 있다.

# 메모리 관리 기법

# RAID

# 흐름제어 VS 혼잡제어
흐름제어는 데이터를 송신하는 곳과 수신하는 곳의 데이터 처리 속도를 조절하여 수신자의 버퍼 오버플로우를 방지하는 것입니다. 예를 들어 송신하는 곳에서 감당이 안되게 데이터를 빠르게 많이 보내면 수신자에서 문제가 발생하기 때문입니다.
혼잡제어는 네트워크 내의 패킷 수가 넘치게 증가하지 않도록 방지하는 것입니다. 만약 정보의 소통량이 과다하면
패킷을 조금만 전송하여 혼잡 붕괴 현상이 일어나는 것을 막습니다.

# DB 트랜잭션
## ACID
* Atomicity 전부 반영되거나 전혀 반영되지 않음.
* Consistency 트랜잭션 전후 데이터 일관성 유지.
* Isolation 트랜잭션 간 독립성 보장.
* Durability 트랜잭션 완료 후 영구적 저장.

# 데이터베이스 정규화:
* 1NF: 중복된 열 제거, 원자성.
* 2NF: 부분 함수 종속 제거.
* 3NF: 이행적 종속 제거.