---
title: 쉘 변수/파일시스템
weight: -1
---
## 쉘 변수
### 지역변수
* 현재 쉘에만 사용 가능한 변수
 
### 환경변수
* 시스템 전체에서 사용 가능한 변수

### 변수 확인
* set: 모든 변수와 함수를 조회
* env: 환경 변수만 조횧
* echo $변수: 변수의 값 출력

### 변수 생성 및 수정
* 변수명=값
* 있으면 수정, 없으면 생성
* 지역 변수를 환경 변수로 수정 export 사용
* 환경변수 지역변수로 수정: export -n 변수명

* unset 변수명
  * 변수삭제
* 변수에 내용 추가
  * 변수명=$변수명:내용
* 환경 변수를 전역에 등록
  * 사용자의 홈 디렉토리의 .bashrc 파일에 환경 변수를 등록해두면 재부팅 할 떄도 환경 변수의 값을 사용 가능
  * 사용자 홈 디렉토리의 .bashrc는 사용자가 로그인 할 때 읽어서 설정을 하는 파일
  * alias나 export를 이용해서 환경변수 만들면 로그인 할 때마다 적용
  * 일반 환경변수를 만들면 다른 곳에서 사용할 수 있도록 만들어지지만 재부팅을 하면 내용이 소멸
  * 재부팅을해도 내용을 유지시키려면 .bashrc파일에 등록을 해야 함

### 쉘 변수 사용
* 내장 명령어는 쉘 변수 사용 가능하지만 외부 명령어는 쉘 변수 사용 불가
* 리눅스 버전에 따라서는 외부 명령어에서 쉘 변수를 사용 가능하도록 해주는 것도 있음, 최신 버전의 리눅스에서는 외부 명령어에서도 쉘 변수 사용이 가능
 ```shell
 DIR=/tmp
 cd $DIR
 /tmp$
 ```

* 제공하는 환경 변수
  * PATH: 실행 파일(명령어)를 찾는 위치
  * PWD: 현재 작업 디렉토리의 절대 경로

### 환경 설정 파일
* 시스템 환경 설정 파일->/etc 디렉토리에 존재
* 종류
```shell
/etc/profile # 모든 쉘에 공통으로 적용되는 환경설정파일
/etc/bash.bashrc # 공통으로 적용되는 bashrc
/etc/profile.d/*.sh # 언어나 명령별로 각각 필요한 환경을 설정
```

### 유저별 환경 설정 파일
* 유저의 홈디렉토리에 존재(~, /home/계정)
* 종류
```shell
~/.profile # .bashrc가 있는 경우에만 수행되는데 사용자가 정의한 환경설정파일
~/.bashrc # 히스토리크기나 환경변수 또는 별명이나 함수
~/.bash_logout # 로그아웃 할 때 수행할 내용
~/.bash_aliases # 별명설정
```

### 읽는 순서
* 시스템이 부팅될 때 시스템 환경 설정 파일을 읽어서 설정을 하고 사용자가 로그인을 하면 사용자의 환경설정 파일을 읽어서 환경 설정 수정을 한 상태로 로그인
* 로그인을 한 후 환경 설정을 변경하면 변경한 환경 설정이 적용

### 적용
* 시스템을 재부팅하거나 로그인을 다시 하면 적용되는데 *재부팅이나 로그인을 하지 않고* 적용하고자 하는 경우는 source 환경설정파일경로 명령을 수행
```shell
source ~/.bash_aliases
source ~/.bash_logout
```
### 덮어쓰기 방지
* 기존의 파일이 존재하는 경우 덮어쓰지 않도록 설정
```shell
set -o noclobber # 덮어쓰기 방지
set +o noclobber # 해제
```

## 파일 시스템
* 유닉스나 리눅스에서 시스템과 관련된 정보와 하드웨어 같은 장치를 모두 파일로 관리
* 파일은 운영체제가 관리
* 프로그램에서 파일을 생성했더라도 파일 관리는 운영체제가 함
* 프로그래밍을 할 때 외부 자원을 사용하는 경우는 특별한 경우가 아니면 예외처리를 해줘야 함
* 외부 자원에 해당하는 것들은 파일, 네트워크, 데이터베이스가 대표적
* 리눅스는 물리적으로 여러 개의 하드디스크를 사용하더라도 하나의 루트 디렉토리를 가짐
* 디렉토리와 장치도 하나의 파일로 간주
* 계층적 디렉토리 구조

### 파일 종류
* 일반 파일
  * 일반적인 파일: 문서파일, 바이너리파일, 기타파일
* 디렉토리: 파일을 구조적으로 관리하기 위해 사용위한 파일
* 링크: 복제본이나 바로가기를 위한 파일
  * 하드링크: 복제본
  * 소프트링크: 바로가기
* 장치: 하드디스크나 키보드같은 장치를 관리하기 위한 파일
  * 대부분 /dev 디렉토리에 존재
* 파일 종류 확인: file 명령으로 확인 가능
```shell
file .profile
file Downloads
file /bin/bash
```

### 디렉토리와 파일관리
* 우분투 파일 시스템은 파일과 디렉터리의 계층형 구조(대부분의 운영체제는 계층형 구조)
* 리눅스는 최상위 디렉터리(루트 디렉터리)가 1개
* 윈도우즈는 물리적인 디스크를 여러개 장착하거나 논리적으로 하나의 디스크를 분할하면 여러개의 루트(드라이브) 생성
* 리눅스는 물리적인 디스크 여러개를 하나의 루트에서 제어 가능
* 리눅스에서 디스크 분할 후 맵-리듀스 가능
* 작업 디렉터리: 현재 사용하고 있는 디렉터리
  * pwd 명령어, 환경변수 PWD가 절대경로 저장, . 으로 나타냄
* 상위 디렉터리: ..
* 루트 디렉터리는 /
* 홈 디렉터리: 사용자 별 디렉터리
  * /home/계정명
  * ~ 로 표시
* 루트에 기본적으로 제공되는 디렉토리
  * ls -aF / => /로 끝나면 디렉터리, @가 붙은 것은 링크
  * bin과 lib 디렉터리는 유닉스 초창기부터 있었던 디렉터리로 지금은 /usr/bin과 /usr/lib로 변경되었는데 명령어 호환성 유지를 위해 심볼릭 링크로 만들어 제공
* /dev: 디바이스 파일이 배치되어 있는 디렉터리
* home: 사용자 디렉터리
* /etc: 리눅스 설정 파일이 위치하는 디렉터리
* /opt: 추가 패키지가 설치되는 디렉터리
* /root: root계정이 사용하는 디렉터리
* /sys: 리눅스 커널과 관련있는 파일이 저장되는 디렉터리
* /usr: 기본 실행 파일과 라이브러리 파일 그리고 헤더 파일이 저장되는 디렉터리
* /boot: 부팅과 관련된 파일
* /lost+found: 파일 시스템에 문제가 발생해서 복구할 경우 문제가 되는 파일이 저장되는 디렉터리
* /mnt: 파일 시스템을 임시로 마운트하는 디렉터리
* /proc: 프로세스 정보가 저장되는 디렉터리(PCB)
* /run: 실행중인 서비스와 관련된 파일이 저장되는 디렉터리
* /srv: FTP나 Web 등 시스템에서 제공하는 서비스의 데이터가 저장되는 디렉터리
* /tmp: 임시 디렉터리로 모든 사용자가 읽고 쓰기 가능
  * 재시작하면 디렉터리의 내용이 모두 삭제될 수 있음
* /var: 시스템 운영 중에 발생하는 데이터나 로그를 저장하는 디렉터리

### 절대 경로와 상대 경로
* 절대 경로는 루트로부터의 경로로 하나만 존재
* 상대 경로를 현재 위치로부터의 경로, .과 ..을 이용해서 표시

### 파일의 구성 요소
* 리눅스에서는 파일을 저장할 때 파일이름 그리고 i-node 그리고 데이터 블록으로 나누어서 저장
* 파일 이름은 절대 경로의 형태로 만들어지고 이 파일 이름은 파일에 대한 정보를 저장한 i-node를 가리키고 i-node가 파일을 실제 저장한 데이터 블록을 가리킴
* 여러 개의 파일 이름이 동일한 i-node를 공유할 수 있음
* 파일이름
  * 유일무이
  * 리눅스나 유닉스에서 .으로 시작하면 숨김파일
* I-node
  * 파일에 대한 정보를 저장
  * 파일의 종류, 파일의 소유권, 파일의 액세스 모드, 파일의 타임 스탬프, 실제 저장 위치 등을 저장
* 데이터 블록
  * 파일의 내용이 *연속적*으로 저장, 블록에서 구분 불가
  * I-node에 파일에 대한 데이터 블록의 연속적 내용을 구분

### 디렉터리 관련 명령어
* pwd: 현재 디렉터리 절대 경로 확인
* cd: 디렉터리를 생략하거나 ~을 사용하면 현재 작업 디렉터리 이동
  * 탭 키를 이용한 자동완성 가능
* ls: 디렉터리의 내용을 출력하는 명령
  - ls [옵션] [디렉터리 나 파일]
  - 디렉터리를 생략하면 현재 디렉터리
  - 디렉터리 대신에 파일 설정하면 파일이름출력, 이를 이용해 파일 존재여부 확인
  - 옵션
    a: 숨김 파일도 출력
    d: 디렉터리 자체 정보 출력
    i: I-node 번호 출력
    l: 파일의 상세 정보
    A: .과 ..를 제외하고 출력
    F: 파일의 종류를 출력(*은 실행파일 /는 디렉터리 @는 심볼릭링크)
    L: 심볼릭 링크의 경우 원본 파일의 정보를 같이 출력
    R: 하위 디렉터리까지 같이 출력

  - 상세정보보기
    - 첫번쨰는 종류
    - d: 디렉터리
    - l: 심볼릭링크
    - b: 블록 장치
    - c: 문자 장치 파일
    - p: 파이프 파일
    - s: 소켓 파일
    - 9개의 문자: 권한
      - rwxrwxrwx: 소유자, 소유자가 속한 그룹, 기타 사용자에 대한 읽기, 쓰기, 실행 권한
    - 그 다음 블록에 나오는 숫자: 하드 링크의 개수(디렉터리는 기본2(. 과 ..))
    - 다음 블록에 나오는 문자열: 소유자
    - 다음 블록에 나오는 문자열: 소유자가 속한 그룹
    - 다음 블록에 나오는 숫자: 파일의 크기, 디렉터리는 4096
    - 다음 블록에 나오는 문자열: 마지막 수정 날짜
    - 다음 블록에 나오는 문자열: 이름
        
  - 디렉터리 자체 정보를 확인하고자 하는 경우 dl옵션 사용
  - dir과 vdir 명령도 제공: windows와 호환성 떄문

- mkdir
  - 디렉터리를 생성하는 명령
  - 디렉터리에 쓰기 권한이 있는 경우에만 생성이 가능
  - 옵션으로는 p가 있는데 p는 중간 디렉터리가 없는 경우 자동 생성

- rmdir
  - 디렉터리를 삭제하는 명령
  - 하위 디렉터리가 있으면 삭제를 못함
  - p옵션을 이용하면 상위 디렉터리가 비어있는 경우 하위 디렉터리도 삭제

### 파일 관련 명령어
> cat
  - 텍스트 파일 출력 명령
  - 문서가 크면 스크롤 기능을 제공
  - 여러 개의 파일을 동시에 출력 가능
  - 파일을 지정하지 않으면 키보드 입력 내용을 그대로 출력
  - n 옵션 이용해서 행 번호 출력 가능
  - /etc/hostname 이라는 파일이 존재

> more
  - 화면 단위로 텍스트 파일 출력
  - 스페이스 바를 이용해서 다음 페이지로 전환, q누르면 중단
  - /문자열 입력하면 해당 문자열 검색 가능
  - +숫자 를 이용하면 시작할 행 번호를 설정 가능
  - 스크롤 기능 없음
  - ex) /etc/services 파일 읽기

> less
  - more 개선
  - 아래 위 방향키로 화면이동 가능하도록 함
  - 지금 버전 more에서도 이 기능 제공

> head/tail
  - 앞의 몇 개의 행이나 뒤의 몇 개의 행을 읽고자 할 때
  - tail 명령에 -f 옵션 사용하면 파일의 내용 변경될 때 자동으로 계속 출력

> cp
  - 파일을 복사하는 명령
  - 형식: cp [옵션] 원본파일경로 복사될파일경로
  - 복사될 파일 경로에 파일이 존재하면 덮어씌움
  - 옵션
    i: 파일이 존재하는 경우 덮어씌울 것인지
    r: 디렉토리를 복사할 때 사용
  - 여러개의 파일을 하나의 디렉토리로 복사가 가능, 이 경우에는 마지막에 있는 경로가 디렉토리
  - 파일을 복사할 때 복사될 파일 경로에 디렉토리만 기재하면 동일한 파일 이름으로 복사가 됨

> rm
  - 파일이나 디렉토리를 삭제하는 명령어
  - 옵션
    i: 대화식으로 물어보면서 삭제
    r: 재귀적으로 삭제
  - 종종 rm -i 를 rm 명령으로 별명을 붙여서 사용하는 경우가 있음

> mv
  - 파일이나 디렉터리를 이동할 때 사용하는 명령어
  - 사용하는 방식은 cp와 동일
  - 이름을 변경하는 것도 가능, 디렉터리 대신 변경할 이름 입력

> file: 파일의 종류를 출력

> ln: 링크를 생성하는 명령
  - 형식: ln [옵션] 원본파일경로 링크파일경로
  - 일종의 파일에 별명을 붙이는것과 유사
  - 사용이유: 긴 경로를 짧게 만들기 위해
  - 여러 버전의 프로그램이 존재하는 경우 이름 구분 위해

> 하드 링크
  - 파일 원본에 이름을 여러 개 붙이는 것과 동일한 효과
  - 만들 때 옵션 없이 생성
  - cp시 새로운 I-노드 블럭 생성
  - ln시 똑같은 I-노드 블럭 생성
  - rm시 각각 삭제
  - I-노드는 참조하는 노드가 없으면 삭제
  - 디렉터리는 하드링크를 만들 수 없음
  - 서로 다른 디스크에 걸쳐서 만들 수 없음

> 심볼릭 링크
  - 윈도우의 바로가기 아이콘과 유사
  - 디렉터리에도 생성 가능하고 다른 디스크에도 생성 가능
  - 원본 파일에 대한 정보가 담긴 특수 파일이며 원본과는 구분(별도의 I-node소유)
  - 심볼릭 링크를 삭제하는 것은 원본에 아무런 영향이 없지만 원본이 지워지면 심볼릭 링크는 깨짐
  - 만드는 방법은 링크를 만들 때 -s 옵션 추가

> find
- 파일을 검색하기 위한 명령어
  ```find [디렉토리 경로] [검색조건]```
- 검색조건:
  name 파일명
  type 파일종류
  user 유저명
  perm 접근권한
  ```find /tmp -name a.txt```
- 동작:
  exec 명령 \: 검색된 결과에 명령을 수행
  ok 명령 {} \: 사용자의 확인을 받아서 명령을 수행
  print: 검색된 파일의 절대 경로명을 화면에 출력
  ls: 긴 목록 형식으로 출력

> locate
- 파일이나 디렉토리를 검색하는 명령
- 기본 명령이 아니라서 설치해서 사용
- 파일이나 디렉터리를 데이터베이스화 해서 검색을 하기 때문에 검색 속도가 빠름
- 검색 옵션이 한정적이고 데이터베이스를 업데이트 하지 않으면 업데이트 이후의 정보는 사용할 수 없음
- 검색 위주인 경우는 locate가 유용하고 검색한 결과를 가지고 작업을 수행하는 경우는 find가 유용
- 정규표현식도 사용 가능

### 파일 접근 관리
- 다중 사용자 시스템은 사용자의 파일에 마음대로 접근 못 하도록 보안 기능 제공
- 접근 권한은 파일이 가지고 있는 속성 중 하나
파일의 접근 권한을 확인할 떄는 ls에 l 옵션을 이용해 상세히 정보를 출력하면 됨

>권한 종류
- 읽기
  - 파일의 경우는 읽거나 복사 가능
  - 디렉터리의 경우는 ls 명령으로 목록은 볼 수 있지만 나머지 옵션은 실행 권한이 있어야 함
- 쓰기
    - 파일은 수정, 이동, 삭제가 가능
    - 디렉터리의 경우는 파일을 생성하거나 삭제할 수 있음
- 실행
  - 파일은 실행이 가능
  - 디렉터리의 경우 cd 명령어 사용 가능
- 표기 방법
  - 권한이 있는 경우 r, w, x로 표기 하고 권한 없는 경우 -로 표시
  - 소유자, 소유자가 속한 그룹, 기타 사용자 이렇게 3개 카테고리로 표시
  - 숫자로 표기, 실제 저장이 될 때는 이진수로 변환이 되서 저장되야 하기 때문에 권한 수정할 때나 외부에 표기할 때 숫자로 표기
  - 각 카테고리를 8진수로 표현해서 표기
  - rwx r-x rw-
    111 101 110
     7   5   6
- 접근 권한 변경
  - `chmod [옵션] 변경할파일경로`
  - 옵션으로 R
  - chmod 카테고리문자 연산자기호 접근권한 파일경로
  - 카테고리 문자
    u: 소유자
    g: 소유자가속한그룹
    o: 기타
    a: 전체
  - 연산자 기호
    +: 권한 부여
    -: 권한 회수
    =: 권한설정
    ```chmod g+wx access.txt```
  - 숫자로 설정하는 경우 chmod 8진수3개 파일경로
    ```chmod 644 access.txt```
- 기본접근권한
  - 파일의 경우 rw-rw-r--
  - 디렉터리의 경우 rwxrwxr-x
- 기본접근권한 확인
  - umask 또는 umask -S
  - umask는 제외할 권한이 숫자로 표시
  - umask -S는 부여할 권한을 문자열로 표시
  - 디렉터리에 대한 권한이고 파일은 여기서 실행 권한이 제거된 상태로 만들어짐
  - mask는 반대
  - rwxrwxr-x는 숫자로 775-> 전부 권한이 부여되는 경우 777 - ? = 775를 만들어주는 ?를 mask라 함
  - 수정: umask 마스크값

- 특수 접근 권한
  - umask의 맨 앞자리
- 종류
  0: 일반적인 파일
  1: sticky bit
  2: SetGID
  3: setUID

- SetUID: 파일이 실행되는 동안 파일을 실행한 소유자의 권한 아니라 파일 소유자의 권한이 적용됨
- 이 설정 하게되면 파일 소유자에게 실행 권한이 있을 때 x가 s로 표시됨
- 실행한 유저가 쓰기 권한이 없더라도 소유자가 쓰기 권한이 있다면 쓰기가 가능
- 이 설정을 하고자 하는 경우는 권한 설정을 할 때 숫자로 하고 세자리 맨 앞에 4를 추가해주면 됨
```bash
touch set.exe # 파일생성: 기본 권한은 664(rw-rw-r--)
chmod 755 set.exe # 모든 유저에게 실행 권한 부여
ls -l set.exe # 권한 확인이 가능(rwxrwxr--)
chmod 4755 set.exe # 모든 유저에게 실행 권한 부여, 실행을 할 때 소유자의 권한으로 실행
ls -l set.exe # 권한 확인이 가능(rwsrwxr--)
```

- SetGID
  - 파일이 실행되는 동안에는 파일을 실행한 사용자의 권한이 아니라 파일 소유자그룹의 권한이 적용됨
- SetUID가 적용된 대표적인 파일이 passwd
- sticky bit: 디렉터리에만 설정할 수 있는데 이 설정이 있으면 모든 유저가 이 디렉터리에 파일을 생성하고 삭제할 수 있음
  - 자신이 생성한 파일만 삭제가 가능
  - 대표적인 디렉터리가 tmp, 기타 사용자의 실행권한이 t로 표시