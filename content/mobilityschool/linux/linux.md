---
title: Linux 기본
linkTitle: Linux 기본
weight: 1
layout: wide
---
## 명령어
### 종료
```bash
poweroff
shutdown -P now #지금 종료
shutdown -P +10 #10분후 종료
shutdown -r 22:00 #22시 재부팅
shutdown -c #예약된 종료 취소
shutdown -k +15 #현재 접속한 사용자에게 15분후 종료한다는 메시지 전송, 실제로는 종료되지 않음
halt -p
init 0
```

### 재부팅
```bash
shutdown -r
reboot
init 6
```

### 로그아웃
* 관리자가 시스템 종료를 하면 접속된 모든 유저의 연결 해제
* 관리자가 접속을 해제하고자 하는 경우 logout이나 exit명령을 이용해서 로그아웃

### init
* run레벨을 의미
```shell
init 0 # 종료
init 1 # 복구 모드로 한 명의 사용자만 접속 가능
init 6 # 재부팅
```
### 명령어 사용법
* SHELL: 명령어 해석기. 터미널이나 원격접속툴에서 명령을 내리면 SHELL이 번역을 해서 kernel에 전달하고 실제 명령이 수행됨
* 기능: 
  * 명령어해석기
  * 프로그래밍
  * 사용자환경설정: shell은 사용자 환경을 설정할 수 있도록 초기화 파일 제공<br>
  전체 설정 파일을 읽은 후 사용자 환경 설정 파일을 읽어서 사용자 별로 환경을 구성
* shell에 보여지는 문자열-프롬프트
  ```shell
  사용자이름@호스트이름(컴퓨터):~$
  슈퍼사용자일 경우 사용자이름@호스트이름(컴퓨터):~#
  ```
  * 로그인 할 때 하나의 shell이 보여지게 됨. 이 shell을 로그인 shell이라함
  * 현재 사용중인 shell 확인하는 명령
  ```shell
  echo $SHELL
  ```
  * ~: 홈디렉토리
* 명령어 입력 시 에러가 발생한 경우
  * 키보드 입력이 안될 시 CTRL + s를 눌러 잠금을 한 경우: CTRL + q를 눌러 잠금해제
  * 명령이 종료되지 않은 경우: CTRL + c 눌러 현재 실행중 프로세스 강제 종료
  * 실수로 텍스트파일이 아닌 파일을 열어 한글이 깨지는 경우: CTRL + l(clear)을 눌러 화면 클리어

* 명령어의 구조는 기본적으로 명령 [옵션] [인자]
* 명령은 실행 프로그램 또는 내장 명령어
* 옵션은 -또는--
  * -다음에는 한글자
  * --다음에는 단어
* 옵션은 대부분의 경우 순서에 상관없이 여러개 입력 가능
* 한글자인 경우 결합가능

```shell
ls -a 또는 ls --all
ls -a -l -> ls -al # 결합 가능
docker -dit -> docker -d -i -t # d=background, i=interactive, t=terminal
```

### 명령어 자동완성
* 입력 중 입력 한 단어로 시작하는 명령이 하나만 존재한다면 tab을 누르면 명령어는 자동완성이 됨. <br>
입력 중 입력한 단어로 시작하는 명령이 여러 개 존재한다면 tab을 한 번 더 누르면 모든 명령 출력

### 명령어 입력방식
* 텍스트파일에 만들어두고 이 파일의 내용을 읽어서 수행: 스크립트 방식이라고 하고 파일의 확장자는 sh

### 히스토리 기능
* 이전에 수행했던 명령어를 저장
* 키보드화살표 사용 또는 CTRL + p, CTRL + n명령 이용
* CTRL + r을 이용하면 증분 모드로 검색 가능
* history라고 입력 시 수행한 모든 명령어 출력
```shell
history
```
* more로 파일내용
```shell
more 파일명
```
### 옵션
* !!: 직전 명령어 수행
* !번호: 번호에 해당하는 명령어 수행
* !문자열: 문자열로 시작하는 마지막 명령어를 수행
* history -d 라인번호: 라인번호에 해당하는 명령어 삭제
* history -c: 모든 명령어를 삭제

* history내용은 홈 디렉토리의 .bash_history파일에 저장되어 있음
* .파일명 -> 숨김파일

### 명령어 도움말
* 명령어 --help
* man이라는 명령어도 도움말을 출력
```shell
man [옵션] [섹션] 명령
```
* shell이 명령어 찾는 위치 - 환경변수 path
* 현재 디렉토리에서 명령을 찾고 없으면 PATH에서 찾고 그래도 없으면 shell내장 명령 수행
```shell
echo $PATH
```
* 명령어의 절대 경로 찾기: whereis [옵션][명령어 - 실행(바이너리) 파일]
* 스케줄링 같은 것을 할 때는 명령어의 절대 경로를 기반으로 수행
* 내장 명령의 경우는 별 문제가 안되지만 내장 명령이 아닌 경우는 절대경로를 알아야함
* 옵션
  * -b: 바이너리 파일만 검색
  * -m: 메뉴얼 파일만 검색
  * -s: 소스 파일만 검색
  ```shell 
  whereis -m ls
  ```
  * which는 명령어를 찾을 때 PATH에서만 찾음
  * a나 i옵션을 이용하는 경우가 있음
* 기타 명령어
  * passwd: 비밀번호 변경
  * exit: 현재사용중인 SHELL종료, 로그인SHELL에서 다른SHELL 실행한 경우는 이전에 실행한 SHELL로 이동
  * clear: 현재 화면 삭제 - CTRL + l

### SSH
```shell
sudo apt-get update
sudo apt-get install openssh-server
sudo systemctl status ssh
sudo ufw allow ssh
```

* 패키지관리자 - central repository의 프로그램/패키지 저장 위한 db <br>
->접속하면 로컬에 DB 가져옴 <br>
->프로그램 업데이트 시 로컬도 업데이트 시켜야->apt-get update <br>
* sudo->관리자 권한
* firewall: inbound제어 못들어오게

* proxy서버: outbound제어
* 유저에 관리자 권한이 없으면 위의 명령이 수행안될 수 있음
```shell
sudo usermod -aG sudo 계정명  # 계정 관리자 권한 설정
```

### 포트포워딩
* 내부의 IP와 외부IP를 매핑해서 내부에서 사설 IP를 사용하지만 외부 IP를 이용해서 인터넷을 할 수 있도록 해주고 외부에서는 설정한 외부IP를 이용해 내부IP를 가진 컴퓨터에 접근할 수 있도록 해줌
* 리눅스에서 사설 IP 조회, 터미널 실행시켜 hostname -i 명령 수행 (ifconfig 명령은 net-tools 설치해야) (Default 주소는 10.0.2.15)
* 터미널이 실행이 안될 때는 [설정] - [Region & Language] 에서 캐나다로 변경하고 로그아웃 후 다시 로그인
* 윈도우즈에서 공인 IP 조회: ipconfig /all<br>
실제 사용하는 어댑터의 IP주소 확인 (인터넷 어댑터 이더넷 2)
* virtual box의 [머신] - [설정] - [고급] - [포트포워딩] 선택 후 룰 추가<br>
포트번호: 22, 호스트IP: 윈도우즈IP, 게스트IP: 리눅스사설IP, 포트번호: 22
* ssh 계정@호스트IP -p 포트번호 으로 접속
* 리눅스 계정 전환
```shell
sudo # 일시적으로 관리자 권한 부여 superuser do
sudo su
su root
su -root # 관리자로 전환
su [계정명] # 특정계정으로 전환
```

### alias
* 별칭 부여
```shell
alias 별명 = '설정값'
unalias # 별명 해제
```
* 어떤 명령이 별명인지 확인하고자 할 때는 type 명령을 입력했을 때 명령이라면 명령 위치 출력, 별명이라면 원본 위치 출력
* ex
```shell
alias ls='ls -F' # alias 설정
unalias ls # 해제
```
* type ls: 별명이라서 명령의 위치가 나오지 않고 별명이라고 출력
* type cp: 별명이 아니라서실제 위치가 출력
  
### 별명이 설정되어 있을 때 원본 명령어를 실행
* 전체 경로로 명령어를 입력(명령어 위치를 whereis나 which 사용)
* command 명령어나 \명령어를 입력

### 날짜 및 시간 명령
* date: 시스템에서 설정되어 있는 현재 시각과 날짜를 출력
* timedatectl: 하드웨어 및 소프트웨어에 설정된 모든 시간과 날짜를 출력

### 시스템 사용자 정보
* logname: 로그인네임
* users: 접속한 사용자 이름
* who: 로그인 한 모든 사용자 계정
* whoami: 현재 사용자

### 시스템 정보 확인
* uname [옵션] <br>
-a: 시스템의 모든 정보 확인<br>
-m: 시스템이 사용 중인 하드웨어 정보 확인<br>
-n: 호스트 네임 확인 - 컴퓨터 이름<br>
-r: 운영체제 릴리즈 번호<br>
-s: 운영체제 이름 <br>
-v: 버전 출시 일자 <br>
* hostname: 현재 사용중인 컴퓨터 이름, 옵션 이용해 IP 확인가능
* arch: CPU 정보
* env: 환경변수 확인

### sudo와 su
* sudo: 일시적으로 관리자 권한으로 실행<br>
패키지 관련 명령이나 환경설정파일 수정할 때 관리자 권한 요청
* su 계정: 현재 계정의 환경변수 유지하면서 다른 계정으로 전환
* su - 계정: 다른 사용자의 계정으로 전환할 때 *환경변수*도 전환
* su: *관리자 계정*으로 전환

### 편집기
* 행단위편집기: ed, ex, sed
* 화면단위편집기: vi(vim), emacs, nano(메뉴기반)
* GUI편집기: gedit
* 모드형 편집기: 입력모드와 명령모드 구분<br>
vi가 대표적인 모드형 편집기
* 비모드형 편집기: 입력모드와 명령모드가 구분되어있지 않음<br>
명령은 CTRL이나 ALT 등과 다른 키를 조합해서 수행<br>
nano가 대표적인 비모드형 편집기

## vim
* vi 이후 개발된 편집기
* vim이라는 이름으로 시작할 수 있고 vi라고 입력해도 vim이 입력됨
* vim 설치->sudo apt-get install vim
* DOCKER 사용 시 설정 파일 수정하려면 호스트OS에서 파일 수정 후 볼륨기능<br>
이용해 파일 복사하는 방법 vs DOCKER 쉘 안에서 직접 편집하는 방법<br>
쉘 안에서 직접 편집하려면 편집기가 설치되어 있지 않아 직접 설치하고 수정해야

### vim 동작모드
* 명령 모드: 커서이동, 페이지이동, 글자삭제, 행삭제
명령 모드에서 입력 모드로 전환은 i, l, o, O, a, A
* 입력 모드: 텍스트입력
  * 입력 모드에서 명령 모드로 전환은 ESC
  * 명령 모드에서 마지막 행 모드로의 전환은 : / ?
  * 마지막 행 모드에서 명령 모드로의 전환은 ESC나 ENTER
  * 명령 모드에서 저장하고 종료는 :wq나 :wq!
  * 명령 모드에서 저장하지 않고 종료는 :q나 :q!
  * 명령 모드에서 종료는 ZZ
* 마지막 행 모드: 검색, 바꾸기

### vim 시작
```shell
vim 파일경로
```
* 파일이 없으면 새로 만들어지는데 저장을 해야 파일이 생성
* 저장하지 않으면 생성 안됨
* 파일이 존재하는 경우 열리게 되는데 수정 권한이 없으면 읽기 전용으로 열림

### 입력 모드 전환 시 i, a, o의 차이
* i는 현재 위치 삽입
* a는 다음 칸에 삽입
* o는 아래 줄에 삽입

### 커서 이동 단축키: 명령모드에서 실행
* $ 현재 행 마지막으로 이동
* \- 현재 행 맨 앞으로 이동
* H 첫번째 행으로 이동
* M 중간 행으로 이동
* L 마지막 행으로 이동

### 원하는 행으로 바로 이동
* 숫자G: 숫자행으로 이동
* 숫자 엔터: 숫자 행으로 이동

### 내용 검색 (중요)
* 텍스트 파일 내용 많을 때 원하는 곳으로 이동
* 마지막 행 모드에서 수행(입력 모드에서 ESC를 눌러서 수행)
* /문자열: 문자열을 아래 방향으로 검색
* ?문자열: 문자열을 위 방향으로 검색
* n: 원래 찾던 방향으로 다음 문자열을 검색
* N: 반대 방향으로 다음 문자열을

### 파일 읽어오기
```shell
:r 파일경로 # 파일을 읽어서 현재 위치에 추가
:e 파일경로 # 지정한 파일로 전환(:w명령으로 저장한 후 수행)
:n # 여러 파일을 한꺼번에 연 경우 다음 파일로 전환
```

### 문서 작성 중 쉘 명령 수행
```shell
:!쉘명령 # vi작접 잠시 중단 후 쉘 명령 수행, vi로 돌아올 땐 ENTER
:sh # vi 잠시 빠져나가 쉘 명령 수행, vi로 돌아올 때 exit
```

### vi 환경 설정 (중요)
* 사용자 홈 디렉토리에 .exrc 파일에 설정 내용을 저장, 모든 파일에 적용 - 재부팅을 해주거나 source 명령을사용
* 환경변수와 설정파일에 동일한 내용 작성 차이: 설정 파일은 로그인 할때 읽어서 설정, 환경 변수는 프로그램 실행할 떄 읽어서 적용
```shell
vi ~/.exrc
```
* 환경변수 중 EXINIT에 지정
```shell
EXINIT='set nu'
export EXINIT
```
* vi의 마지막 행 모드에서 명령으로 설정: 현재 작업 중인 파일에만 적용
```shell
set nu # 라인번호 출력
set list # 눈에 보이지 않는 특수문자 출력
set showmode # 현재 모드를 출력
set ai # 윗 라인과 들여쓰기를 맞춰줌
set si # 코딩할 때 if 나 for 같은 블럭 명령어를 사용하면 다음 라인으로 이동할 떄 들여쓰기
set paste # 붙여넣기를 발생하는 계단 현상 방지
set ts=숫자 # 탭의 간격 설정
set ic # 검색할 때 대소문자 구분않음
set no # 설정해제
```
## SHELL
### 개요
* 사용자가 입력한 명령을 해석해서 커널로 전달하거나 커널의 처리 결과를 사용자에게 전달하는 역할을 수행하는 구성 요소
* OS: hw -> kernel -> shell -> util, application
* server의 텍스트 모드나 GNOME의 터미널을 이용해 명령어를 입력하고 결과를 화면에 출력

### 기능
* 명령어 해석기
* 프로그래밍
* 사용자 환경설정

### 종류
* bourneshell: 초창기의 쉘, 현재 사용X
* C shell
* Korn shell
* bash: C shell과 Korn shell 장점 혼합, 현재 리눅스 기본 shell
* 현재 리눅스 기본 쉘: tsch, dash, zsh

### bash 쉘 특징
* alias 기능 제공
* history 기능 제공
* 명령어 자동완성 기능 제공
* 연산 기능 제공
* Job control 기능 제공

### 쉘 변경
* 지원하는 쉘 확인
```shell
cat /etc/shells
```
* 사용자의 로그인 쉘 확인
```shell
grep 사용자계정 /etc/passwd
```
* C shell 설치
```shell
sudo apt-get install csh
```
* 로그인 쉘 변경
```shell
chsh 옵션 쉘의경로 사용자계정 # 쉘의경로는 절대경로
chsh -s /usr/bin/csh dh # C shell로 변경
chsh -s /usr/bin/dash dh # dash shell로 변경
```
  * C shell 예전 설치 시 /bin/csh에 설치 -> 지금은 /usr/bin/csh에 설치
  * 충돌 방지 위해 예전 경로와 지금 경로 바로가기 연결
  * source파일: 코드, 바이너리파일: 컴파일, 매뉴얼파일: 묶어놈
  * dash 쉘은 프롬프트가 $이고 bash쉘은 유저이름과 호스트이름이 같이 출력
  * C shell로 변경 시 프롬프트가 #으로 변경

* 서브 쉘 생성
  * exit하면 이전쉘로 돌아감
```shell
쉘이름 -s sh 사용자계정
```
* 현재 사용자 쉘 확인
```shell
echo $SHELL
```
* 로그아웃
```shell
exit
```

### 쉘 내장 명령
* 별도의 실행 파일을 가지지 않고 쉘이 내장하고 있는 명령어
* 쉘 별로 이 명령어가 다를 수 있음
* pwd는 쉘 내장명령이 아니고 cd는 쉘 내장명령임
* echo 변수나 문자열을 출력
```shell
echo [-n] 문자열 또는 변수 # -n은 출력하고 마지막에 줄바꿈 않음
```
* shell에서 변수는 앞에 $가 붙음
* printf C언어의 printf와 동일
  * %로 시작하는 형식하된 서식 사용가능
  * 내장하고 있는 쉘도 있고 없는 쉘도 있음 
 ```shell
  printf "%d + %d = %d\n" 100 200 300
 ```

### 특수문자
* 쉘에서는 사용자가 편리하게 명령을 입력하고 실행할 수 있도록 특수문자를 제공
* 거의 모드 쉘에서 특수문자의 기능은 동일
* \* 
  * 임의의 문자열을 의미, 글자수와 상관없이 매핑
  * ls \* 현재 디렉토리 및 서브디렉토리 내용 모두 출력
  * \*.txt, cp \*, t\*.
* ?
  * 한 글자
  * SQL: %->* _->?
* [ ]
  * 여러 개 중 한글자 선택할 때
  * \-를 이용해 범위 설정 가능
  * 범위는 코드값을 기준으로 함
  * 숫자 0은 48, 9는 57, A는 65, Z는 90, a는 97, z는 122
  * A-Z: 대문자, a-z: 소문자, 0-9: 숫자, 가-힣: 한글, a-zA-z: 영문자
  * 현대 디렉토리에서 대문자로 시작하는 파일만 /tmp로 복사
* ~
  * 사용자 홈 디렉토리
* \-
  * 현대 디렉토리로 이동하기 전의 디렉토리
* `
  * 문자열에서 백틱으로 명령을 묶으면 명령을 수행해서 문자열 안에 포함
 ```shell
 echo "Today is `date`"
 Today is Tue Sep  3 15:41:44 KST 2024
 ```
* ;
  * 여러 개의 명령을 사용할 때 순서대로 실행하고자 하는 경우 사용
 ```shell
 date;ls;
 ```
* |
  * 앞 명령의 결과를 뒤 명령에 전달해서 수행
  * 루트 디렉토리의 모든 내용을 출력해서 페이지 단위로 확인
 ```shell
 ls -al / | cat
 ```
* \
  * 에스케이프
  * 특수문자를 포함하는 데이터를 ''로 묶어도 특수문자 기능 무시
  * ""로 묶으면 $;\,{},[]는 원래대로 처리하고 나머지 무시

### 입출력 리다이렉션
* 표준입출력
  * 표준 입력은 일반적으로 키보드 입력
  * 표준 출력은 모니터를 의미

* 리다이렉션
  * 입출력의 방향을 변경
  * 파일로 변경

* \>
  * 출력을 뒤에 있는 장치(리눅스는 하드웨어도 파일로 간주)로 변경
  * 출력하는 장치를 매번 새로만듬
* \>\>
  * 출력을 뒤에 있는 장치(리눅스는 하드웨어도 파일로 간주)로 변경
  * 출력하는 장치 뒤에 추가
  * \>, \>\> 는 출력의 결과를 특정 파일에 기록하기 위해 사용
* 에러 출력 리다이렉션
  * 명령 다음에 2를 추가하고 출력 리다이렉션을 이용하면 표준
 ```shell
 ls /abc 2> ls.err
 ```

 ### 입력 리다이렉션
 * 명령어에 파일의 내용을 추가하고자 할 때 사용
 * 자주 사용하는 옵션이나 인자가 있을 때 활용 가능
 * < 파일경로

## 쉘 변수
### 지역변수
* 현재 쉘에만 사용 가능한 변수
 
### 환경변수
* 시스템 전체에서 사용 가능한 변수

### 변수 확인
* set: 모든 변수와 함수를 조회
* env: 환경 변수만 조횧
* echo $변수: 변수의 값 출력

### 변수 생성 및 수정
* 변수명=값
* 있으면 수정, 없으면 생성
* 지역 변수를 환경 변수로 수정 export 사용
* 환경변수 지역변수로 수정: export -n 변수명

* unset 변수명
  * 변수삭제
* 변수에 내용 추가
  * 변수명=$변수명:내용
* 환경 변수를 전역에 등록
  * 사용자의 홈 디렉토리의 .bashrc 파일에 환경 변수를 등록해두면 재부팅 할 떄도 환경 변수의 값을 사용 가능
  * 사용자 홈 디렉토리의 .bashrc는 사용자가 로그인 할 때 읽어서 설정을 하는 파일
  * alias나 export를 이용해서 환경변수 만들면 로그인 할 때마다 적용
  * 일반 환경변수를 만들면 다른 곳에서 사용할 수 있도록 만들어지지만 재부팅을 하면 내용이 소멸
  * 재부팅을해도 내용을 유지시키려면 .bashrc파일에 등록을 해야 함

### 쉘 변수 사용
* 내장 명령어는 쉘 변수 사용 가능하지만 외부 명령어는 쉘 변수 사용 불가
* 리눅스 버전에 따라서는 외부 명령어에서 쉘 변수를 사용 가능하도록 해주는 것도 있음, 최신 버전의 리눅스에서는 외부 명령어에서도 쉘 변수 사용이 가능
 ```shell
 DIR=/tmp
 cd $DIR
 /tmp$
 ```

* 제공하는 환경 변수
  * PATH: 실행 파일(명령어)를 찾는 위치
  * PWD: 현재 작업 디렉토리의 절대 경로

### 환경 설정 파일
* 시스템 환경 설정 파일->/etc 디렉토리에 존재
* 종류
```shell
/etc/profile # 모든 쉘에 공통으로 적용되는 환경설정파일
/etc/bash.bashrc # 공통으로 적용되는 bashrc
/etc/profile.d/*.sh # 언어나 명령별로 각각 필요한 환경을 설정
```

### 유저별 환경 설정 파일
* 유저의 홈디렉토리에 존재(~, /home/계정)
* 종류
```shell
~/.profile # .bashrc가 있는 경우에만 수행되는데 사용자가 정의한 환경설정파일
~/.bashrc # 히스토리크기나 환경변수 또는 별명이나 함수
~/.bash_logout # 로그아웃 할 때 수행할 내용
~/.bash_aliases # 별명설정
```

### 읽는 순서
* 시스템이 부팅될 때 시스템 환경 설정 파일을 읽어서 설정을 하고 사용자가 로그인을 하면 사용자의 환경설정 파일을 읽어서 환경 설정 수정을 한 상태로 로그인
* 로그인을 한 후 환경 설정을 변경하면 변경한 환경 설정이 적용

### 적용
* 시스템을 재부팅하거나 로그인을 다시 하면 적용되는데 *재부팅이나 로그인을 하지 않고* 적용하고자 하는 경우는 source 환경설정파일경로 명령을 수행
```shell
source ~/.bash_aliases
source ~/.bash_logout
```
### 덮어쓰기 방지
* 기존의 파일이 존재하는 경우 덮어쓰지 않도록 설정
```shell
set -o noclobber # 덮어쓰기 방지
set +o noclobber # 해제
```

## 파일 시스템
* 유닉스나 리눅스에서 시스템과 관련된 정보와 하드웨어 같은 장치를 모두 파일로 관리
* 파일은 운영체제가 관리
* 프로그램에서 파일을 생성했더라도 파일 관리는 운영체제가 함
* 프로그래밍을 할 때 외부 자원을 사용하는 경우는 특별한 경우가 아니면 예외처리를 해줘야 함
* 외부 자원에 해당하는 것들은 파일, 네트워크, 데이터베이스가 대표적
* 리눅스는 물리적으로 여러 개의 하드디스크를 사용하더라도 하나의 루트 디렉토리를 가짐
* 디렉토리와 장치도 하나의 파일로 간주
* 계층적 디렉토리 구조

### 파일 종류
* 일반 파일
  * 일반적인 파일: 문서파일, 바이너리파일, 기타파일
* 디렉토리: 파일을 구조적으로 관리하기 위해 사용위한 파일
* 링크: 복제본이나 바로가기를 위한 파일
  * 하드링크: 복제본
  * 소프트링크: 바로가기
* 장치: 하드디스크나 키보드같은 장치를 관리하기 위한 파일
  * 대부분 /dev 디렉토리에 존재
* 파일 종류 확인: file 명령으로 확인 가능
```shell
file .profile
file Downloads
file /bin/bash
```

### 디렉토리와 파일관리
* 우분투 파일 시스템은 파일과 디렉터리의 계층형 구조(대부분의 운영체제는 계층형 구조)
* 리눅스는 최상위 디렉터리(루트 디렉터리)가 1개
* 윈도우즈는 물리적인 디스크를 여러개 장착하거나 논리적으로 하나의 디스크를 분할하면 여러개의 루트(드라이브) 생성
* 리눅스는 물리적인 디스크 여러개를 하나의 루트에서 제어 가능
* 리눅스에서 디스크 분할 후 맵-리듀스 가능
* 작업 디렉터리: 현재 사용하고 있는 디렉터리
  * pwd 명령어, 환경변수 PWD가 절대경로 저장, . 으로 나타냄
* 상위 디렉터리: ..
* 루트 디렉터리는 /
* 홈 디렉터리: 사용자 별 디렉터리
  * /home/계정명
  * ~ 로 표시
* 루트에 기본적으로 제공되는 디렉토리
  * ls -aF / => /로 끝나면 디렉터리, @가 붙은 것은 링크
  * bin과 lib 디렉터리는 유닉스 초창기부터 있었던 디렉터리로 지금은 /usr/bin과 /usr/lib로 변경되었는데 명령어 호환성 유지를 위해 심볼릭 링크로 만들어 제공
* /dev: 디바이스 파일이 배치되어 있는 디렉터리
* home: 사용자 디렉터리
* /etc: 리눅스 설정 파일이 위치하는 디렉터리
* /opt: 추가 패키지가 설치되는 디렉터리
* /root: root계정이 사용하는 디렉터리
* /sys: 리눅스 커널과 관련있는 파일이 저장되는 디렉터리
* /usr: 기본 실행 파일과 라이브러리 파일 그리고 헤더 파일이 저장되는 디렉터리
* /boot: 부팅과 관련된 파일
* /lost+found: 파일 시스템에 문제가 발생해서 복구할 경우 문제가 되는 파일이 저장되는 디렉터리
* /mnt: 파일 시스템을 임시로 마운트하는 디렉터리
* /proc: 프로세스 정보가 저장되는 디렉터리(PCB)
* /run: 실행중인 서비스와 관련된 파일이 저장되는 디렉터리
* /srv: FTP나 Web 등 시스템에서 제공하는 서비스의 데이터가 저장되는 디렉터리
* /tmp: 임시 디렉터리로 모든 사용자가 읽고 쓰기 가능
  * 재시작하면 디렉터리의 내용이 모두 삭제될 수 있음
* /var: 시스템 운영 중에 발생하는 데이터나 로그를 저장하는 디렉터리

### 절대 경로와 상대 경로
* 절대 경로는 루트로부터의 경로로 하나만 존재
* 상대 경로를 현재 위치로부터의 경로, .과 ..을 이용해서 표시

### 파일의 구성 요소
* 리눅스에서는 파일을 저장할 때 파일이름 그리고 i-node 그리고 데이터 블록으로 나누어서 저장
* 파일 이름은 절대 경로의 형태로 만들어지고 이 파일 이름은 파일에 대한 정보를 저장한 i-node를 가리키고 i-node가 파일을 실제 저장한 데이터 블록을 가리킴
* 여러 개의 파일 이름이 동일한 i-node를 공유할 수 있음
* 파일이름
  * 유일무이
  * 리눅스나 유닉스에서 .으로 시작하면 숨김파일
* I-node
  * 파일에 대한 정보를 저장
  * 파일의 종류, 파일의 소유권, 파일의 액세스 모드, 파일의 타임 스탬프, 실제 저장 위치 등을 저장
* 데이터 블록
  * 파일의 내용이 *연속적*으로 저장, 블록에서 구분 불가
  * I-node에 파일에 대한 데이터 블록의 연속적 내용을 구분

### 디렉터리 관련 명령어
* pwd: 현재 디렉터리 절대 경로 확인
* cd: 디렉터리를 생략하거나 ~을 사용하면 현재 작업 디렉터리 이동
  * 탭 키를 이용한 자동완성 가능
* ls: 디렉터리의 내용을 출력하는 명령
  - ls [옵션] [디렉터리 나 파일]
  - 디렉터리를 생략하면 현재 디렉터리
  - 디렉터리 대신에 파일 설정하면 파일이름출력, 이를 이용해 파일 존재여부 확인
  - 옵션
    a: 숨김 파일도 출력
    d: 디렉터리 자체 정보 출력
    i: I-node 번호 출력
    l: 파일의 상세 정보
    A: .과 ..를 제외하고 출력
    F: 파일의 종류를 출력(*은 실행파일 /는 디렉터리 @는 심볼릭링크)
    L: 심볼릭 링크의 경우 원본 파일의 정보를 같이 출력
    R: 하위 디렉터리까지 같이 출력

  - 상세정보보기
    - 첫번쨰는 종류
    - d: 디렉터리
    - l: 심볼릭링크
    - b: 블록 장치
    - c: 문자 장치 파일
    - p: 파이프 파일
    - s: 소켓 파일
    - 9개의 문자: 권한
      - rwxrwxrwx: 소유자, 소유자가 속한 그룹, 기타 사용자에 대한 읽기, 쓰기, 실행 권한
    - 그 다음 블록에 나오는 숫자: 하드 링크의 개수(디렉터리는 기본2(. 과 ..))
    - 다음 블록에 나오는 문자열: 소유자
    - 다음 블록에 나오는 문자열: 소유자가 속한 그룹
    - 다음 블록에 나오는 숫자: 파일의 크기, 디렉터리는 4096
    - 다음 블록에 나오는 문자열: 마지막 수정 날짜
    - 다음 블록에 나오는 문자열: 이름
        
  - 디렉터리 자체 정보를 확인하고자 하는 경우 dl옵션 사용
  - dir과 vdir 명령도 제공: windows와 호환성 떄문

- mkdir
  - 디렉터리를 생성하는 명령
  - 디렉터리에 쓰기 권한이 있는 경우에만 생성이 가능
  - 옵션으로는 p가 있는데 p는 중간 디렉터리가 없는 경우 자동 생성

- rmdir
  - 디렉터리를 삭제하는 명령
  - 하위 디렉터리가 있으면 삭제를 못함
  - p옵션을 이용하면 상위 디렉터리가 비어있는 경우 하위 디렉터리도 삭제

### 파일 관련 명령어
> cat
  - 텍스트 파일 출력 명령
  - 문서가 크면 스크롤 기능을 제공
  - 여러 개의 파일을 동시에 출력 가능
  - 파일을 지정하지 않으면 키보드 입력 내용을 그대로 출력
  - n 옵션 이용해서 행 번호 출력 가능
  - /etc/hostname 이라는 파일이 존재

> more
  - 화면 단위로 텍스트 파일 출력
  - 스페이스 바를 이용해서 다음 페이지로 전환, q누르면 중단
  - /문자열 입력하면 해당 문자열 검색 가능
  - +숫자 를 이용하면 시작할 행 번호를 설정 가능
  - 스크롤 기능 없음
  - ex) /etc/services 파일 읽기

> less
  - more 개선
  - 아래 위 방향키로 화면이동 가능하도록 함
  - 지금 버전 more에서도 이 기능 제공

> head/tail
  - 앞의 몇 개의 행이나 뒤의 몇 개의 행을 읽고자 할 때
  - tail 명령에 -f 옵션 사용하면 파일의 내용 변경될 때 자동으로 계속 출력

> cp
  - 파일을 복사하는 명령
  - 형식: cp [옵션] 원본파일경로 복사될파일경로
  - 복사될 파일 경로에 파일이 존재하면 덮어씌움
  - 옵션
    i: 파일이 존재하는 경우 덮어씌울 것인지
    r: 디렉토리를 복사할 때 사용
  - 여러개의 파일을 하나의 디렉토리로 복사가 가능, 이 경우에는 마지막에 있는 경로가 디렉토리
  - 파일을 복사할 때 복사될 파일 경로에 디렉토리만 기재하면 동일한 파일 이름으로 복사가 됨

> rm
  - 파일이나 디렉토리를 삭제하는 명령어
  - 옵션
    i: 대화식으로 물어보면서 삭제
    r: 재귀적으로 삭제
  - 종종 rm -i 를 rm 명령으로 별명을 붙여서 사용하는 경우가 있음

> mv
  - 파일이나 디렉터리를 이동할 때 사용하는 명령어
  - 사용하는 방식은 cp와 동일
  - 이름을 변경하는 것도 가능, 디렉터리 대신 변경할 이름 입력

> file: 파일의 종류를 출력

> ln: 링크를 생성하는 명령
  - 형식: ln [옵션] 원본파일경로 링크파일경로
  - 일종의 파일에 별명을 붙이는것과 유사
  - 사용이유: 긴 경로를 짧게 만들기 위해
  - 여러 버전의 프로그램이 존재하는 경우 이름 구분 위해

> 하드 링크
  - 파일 원본에 이름을 여러 개 붙이는 것과 동일한 효과
  - 만들 때 옵션 없이 생성
  - cp시 새로운 I-노드 블럭 생성
  - ln시 똑같은 I-노드 블럭 생성
  - rm시 각각 삭제
  - I-노드는 참조하는 노드가 없으면 삭제
  - 디렉터리는 하드링크를 만들 수 없음
  - 서로 다른 디스크에 걸쳐서 만들 수 없음

> 심볼릭 링크
  - 윈도우의 바로가기 아이콘과 유사
  - 디렉터리에도 생성 가능하고 다른 디스크에도 생성 가능
  - 원본 파일에 대한 정보가 담긴 특수 파일이며 원본과는 구분(별도의 I-node소유)
  - 심볼릭 링크를 삭제하는 것은 원본에 아무런 영향이 없지만 원본이 지워지면 심볼릭 링크는 깨짐
  - 만드는 방법은 링크를 만들 때 -s 옵션 추가

> find
- 파일을 검색하기 위한 명령어
  ```find [디렉토리 경로] [검색조건]```
- 검색조건:
  name 파일명
  type 파일종류
  user 유저명
  perm 접근권한
  ```find /tmp -name a.txt```
- 동작:
  exec 명령 \: 검색된 결과에 명령을 수행
  ok 명령 {} \: 사용자의 확인을 받아서 명령을 수행
  print: 검색된 파일의 절대 경로명을 화면에 출력
  ls: 긴 목록 형식으로 출력

> locate
- 파일이나 디렉토리를 검색하는 명령
- 기본 명령이 아니라서 설치해서 사용
- 파일이나 디렉터리를 데이터베이스화 해서 검색을 하기 때문에 검색 속도가 빠름
- 검색 옵션이 한정적이고 데이터베이스를 업데이트 하지 않으면 업데이트 이후의 정보는 사용할 수 없음
- 검색 위주인 경우는 locate가 유용하고 검색한 결과를 가지고 작업을 수행하는 경우는 find가 유용
- 정규표현식도 사용 가능

### 파일 접근 관리
- 다중 사용자 시스템은 사용자의 파일에 마음대로 접근 못 하도록 보안 기능 제공
- 접근 권한은 파일이 가지고 있는 속성 중 하나
파일의 접근 권한을 확인할 떄는 ls에 l 옵션을 이용해 상세히 정보를 출력하면 됨

>권한 종류
- 읽기
  - 파일의 경우는 읽거나 복사 가능
  - 디렉터리의 경우는 ls 명령으로 목록은 볼 수 있지만 나머지 옵션은 실행 권한이 있어야 함
- 쓰기
    - 파일은 수정, 이동, 삭제가 가능
    - 디렉터리의 경우는 파일을 생성하거나 삭제할 수 있음
- 실행
  - 파일은 실행이 가능
  - 디렉터리의 경우 cd 명령어 사용 가능
- 표기 방법
  - 권한이 있는 경우 r, w, x로 표기 하고 권한 없는 경우 -로 표시
  - 소유자, 소유자가 속한 그룹, 기타 사용자 이렇게 3개 카테고리로 표시
  - 숫자로 표기, 실제 저장이 될 때는 이진수로 변환이 되서 저장되야 하기 때문에 권한 수정할 때나 외부에 표기할 때 숫자로 표기
  - 각 카테고리를 8진수로 표현해서 표기
  - rwx r-x rw-
    111 101 110
     7   5   6
- 접근 권한 변경
  - `chmod [옵션] 변경할파일경로`
  - 옵션으로 R
  - chmod 카테고리문자 연산자기호 접근권한 파일경로
  - 카테고리 문자
    u: 소유자
    g: 소유자가속한그룹
    o: 기타
    a: 전체
  - 연산자 기호
    +: 권한 부여
    -: 권한 회수
    =: 권한설정
    ```chmod g+wx access.txt```
  - 숫자로 설정하는 경우 chmod 8진수3개 파일경로
    ```chmod 644 access.txt```
- 기본접근권한
  - 파일의 경우 rw-rw-r--
  - 디렉터리의 경우 rwxrwxr-x
- 기본접근권한 확인
  - umask 또는 umask -S
  - umask는 제외할 권한이 숫자로 표시
  - umask -S는 부여할 권한을 문자열로 표시
  - 디렉터리에 대한 권한이고 파일은 여기서 실행 권한이 제거된 상태로 만들어짐
  - mask는 반대
  - rwxrwxr-x는 숫자로 775-> 전부 권한이 부여되는 경우 777 - ? = 775를 만들어주는 ?를 mask라 함
  - 수정: umask 마스크값

- 특수 접근 권한
  - umask의 맨 앞자리
- 종류
  0: 일반적인 파일
  1: sticky bit
  2: SetGID
  3: setUID

- SetUID: 파일이 실행되는 동안 파일을 실행한 소유자의 권한 아니라 파일 소유자의 권한이 적용됨
- 이 설정 하게되면 파일 소유자에게 실행 권한이 있을 때 x가 s로 표시됨
- 실행한 유저가 쓰기 권한이 없더라도 소유자가 쓰기 권한이 있다면 쓰기가 가능
- 이 설정을 하고자 하는 경우는 권한 설정을 할 때 숫자로 하고 세자리 맨 앞에 4를 추가해주면 됨
```bash
touch set.exe # 파일생성: 기본 권한은 664(rw-rw-r--)
chmod 755 set.exe # 모든 유저에게 실행 권한 부여
ls -l set.exe # 권한 확인이 가능(rwxrwxr--)
chmod 4755 set.exe # 모든 유저에게 실행 권한 부여, 실행을 할 때 소유자의 권한으로 실행
ls -l set.exe # 권한 확인이 가능(rwsrwxr--)
```

- SetGID
  - 파일이 실행되는 동안에는 파일을 실행한 사용자의 권한이 아니라 파일 소유자그룹의 권한이 적용됨
- SetUID가 적용된 대표적인 파일이 passwd
- sticky bit: 디렉터리에만 설정할 수 있는데 이 설정이 있으면 모든 유저가 이 디렉터리에 파일을 생성하고 삭제할 수 있음
  - 자신이 생성한 파일만 삭제가 가능
  - 대표적인 디렉터리가 tmp, 기타 사용자의 실행권한이 t로 표시