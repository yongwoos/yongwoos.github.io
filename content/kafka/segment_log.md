---
title: Segment와 log
weight: 7
---
## 파티션과 세그먼트 요약
파티션은 세그먼트들로 구성됨. 하나의 세그먼트는 3개의 파일(.log, .index, timestamp)로 이루어지며 .log 파일에 실제 데이터가 기록된다. 이러한 데이터를 레코드라 부름. .log 파일에 특정 수의 레코드가 기록되면 새로운 .log 파일이 생성된다. .log 파일의 이름은 시작 오프셋을 표기해 나타낸다. 예시로 각 .log파일이 10개의 레코드를 가진다고 하면 처음 세그먼트가 생성되면 00000000.log 파일이 생성되고 10번째 레코드가 기록되면 000000010.log 파일이 새로 생성된다.

.index파일에는 레코드 오프셋 번호와 해당 레코드가 실제 .log파일에 저장된 메시지의 매핑을 저장한다.

## 자세한 설명
Apache Kafka에서 파티션은 특정한 데이터 파일로 관리되며, 각 파티션은 브로커의 로컬 디스크에 저장됩니다. 파티션을 관리하는 파일은 다음과 같이 구성됩니다:
### **카프카 파티션의 파일 구조**
Kafka는 각 토픽의 파티션 데이터를 디스크에 다음과 같은 파일들로 저장합니다:

1. **로그 파일 (.log)**  
   각 파티션의 실제 메시지 데이터가 저장됩니다. 로그 파일은 하나의 시퀀셜 로그 구조로, 기본적으로 설정된 크기(`log.segment.bytes`)에 도달하면 새로운 세그먼트 파일로 회전됩니다.

   - 예: `my-topic-0-00000000000000000000.log`

2. **인덱스 파일 (.index)**  
   메시지 오프셋과 해당 메시지가 로그 파일에 저장된 위치 간의 매핑을 저장합니다. 인덱스 파일은 빠른 조회를 가능하게 합니다.

   - 예: `my-topic-0-00000000000000000000.index`

3. **타임스탬프 인덱스 파일 (.timeindex)**  
   메시지의 타임스탬프와 로그 파일 위치 간의 매핑을 저장합니다. 특정 타임스탬프를 기준으로 데이터를 검색할 때 사용됩니다.

   - 예: `my-topic-0-00000000000000000000.timeindex`

### **파일 핸들 관리**
Kafka 브로커는 각 파티션의 파일 핸들을 관리해야 하며, 이를 효율적으로 처리하기 위해 다음과 같은 방법을 사용합니다:

1. **파일 핸들 캐싱**  
   브로커는 자주 사용되는 파티션의 파일 핸들을 캐시합니다.  
   - 캐시된 파일 핸들은 디스크 I/O를 줄이고 성능을 높이는 데 도움을 줍니다.  
   - 캐싱 크기는 브로커 설정(`num.io.threads`, `log.dirs`)과 관련이 있습니다.

2. **Lazy File Open**  
   Kafka는 필요한 시점에만 파일 핸들을 열어 리소스를 절약합니다.  
   - 덜 사용되는 파티션은 파일 핸들을 닫아둡니다.

3. **OS 파일 핸들 제한**  
   Linux 시스템에서 파일 핸들 개수 제한(`ulimit -n`)은 Kafka 운영에 큰 영향을 줍니다.  
   - 운영 환경에서 `ulimit -n` 값을 충분히 높게 설정해야 합니다.  
   - 일반적으로 Kafka는 브로커당 수만 개의 파일 핸들을 필요로 할 수 있습니다.

4. **파일 핸들 수를 줄이기 위한 설정**  
   - **`log.retention`**: 오래된 로그 파일 삭제를 설정.  
   - **`log.segment.bytes`**: 로그 세그먼트 크기를 조정하여 파일 수를 관리.  
   - **`log.segment.ms`**: 세그먼트 회전 주기를 줄여도 파일 핸들을 최적화 가능.

### **장애 상황 처리**
파일 핸들이 부족하거나 관련 오류가 발생하면:
- `Too many open files` 에러가 발생.  
- Kafka 브로커 로그에서 파일 핸들 관련 경고를 확인 가능.  
- `ulimit`, 로그 세그먼트 크기 조정 및 파티션 수 최적화로 해결 가능.  

이처럼 파일 핸들 관리는 Kafka 브로커의 안정성과 성능에 매우 중요합니다.